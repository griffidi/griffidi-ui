# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCustomer {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
}

type AggregateCustomerContact {
  _count: CustomerContactCountAggregate
  _max: CustomerContactMaxAggregate
  _min: CustomerContactMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type CreateManyAndReturnCustomer {
  address: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  name: String!
  phone: String!
}

type CreateManyAndReturnCustomerContact {
  customer: Customer!
  customerId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
}

type CreateManyAndReturnUser {
  address: String!
  dateCreated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  phone: String!
  role: String!
}

type Customer {
  CustomerContact(cursor: CustomerContactWhereUniqueInput, distinct: [CustomerContactScalarFieldEnum!], orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): [CustomerContact!]!
  _count: CustomerCount
  address: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  name: String!
  phone: String!
}

type CustomerContact {
  customer: Customer!
  customerId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
}

type CustomerContactCountAggregate {
  _all: Int!
  customerId: Int!
  dateCreated: Int!
  dateUpdated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  phone: Int!
}

input CustomerContactCountOrderByAggregateInput {
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
}

input CustomerContactCreateInput {
  customer: CustomerCreateNestedOneWithoutCustomerContactInput!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
}

input CustomerContactCreateManyCustomerInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
}

input CustomerContactCreateManyCustomerInputEnvelope {
  data: [CustomerContactCreateManyCustomerInput!]!
}

input CustomerContactCreateManyInput {
  customerId: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
}

input CustomerContactCreateNestedManyWithoutCustomerInput {
  connect: [CustomerContactWhereUniqueInput!]
  connectOrCreate: [CustomerContactCreateOrConnectWithoutCustomerInput!]
  create: [CustomerContactCreateWithoutCustomerInput!]
  createMany: CustomerContactCreateManyCustomerInputEnvelope
}

input CustomerContactCreateOrConnectWithoutCustomerInput {
  create: CustomerContactCreateWithoutCustomerInput!
  where: CustomerContactWhereUniqueInput!
}

input CustomerContactCreateWithoutCustomerInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
}

type CustomerContactGroupBy {
  _count: CustomerContactCountAggregate
  _max: CustomerContactMaxAggregate
  _min: CustomerContactMinAggregate
  customerId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
}

input CustomerContactListRelationFilter {
  every: CustomerContactWhereInput
  none: CustomerContactWhereInput
  some: CustomerContactWhereInput
}

type CustomerContactMaxAggregate {
  customerId: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}

input CustomerContactMaxOrderByAggregateInput {
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
}

type CustomerContactMinAggregate {
  customerId: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}

input CustomerContactMinOrderByAggregateInput {
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
}

input CustomerContactOrderByRelationAggregateInput {
  _count: SortOrder
}

input CustomerContactOrderByWithAggregationInput {
  _count: CustomerContactCountOrderByAggregateInput
  _max: CustomerContactMaxOrderByAggregateInput
  _min: CustomerContactMinOrderByAggregateInput
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
}

input CustomerContactOrderByWithRelationInput {
  customer: CustomerOrderByWithRelationInput
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
}

enum CustomerContactScalarFieldEnum {
  customerId
  dateCreated
  dateUpdated
  email
  firstName
  id
  lastName
  phone
}

input CustomerContactScalarWhereInput {
  AND: [CustomerContactScalarWhereInput!]
  NOT: [CustomerContactScalarWhereInput!]
  OR: [CustomerContactScalarWhereInput!]
  customerId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  phone: StringFilter
}

input CustomerContactScalarWhereWithAggregatesInput {
  AND: [CustomerContactScalarWhereWithAggregatesInput!]
  NOT: [CustomerContactScalarWhereWithAggregatesInput!]
  OR: [CustomerContactScalarWhereWithAggregatesInput!]
  customerId: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
}

input CustomerContactUpdateInput {
  customer: CustomerUpdateOneRequiredWithoutCustomerContactNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}

input CustomerContactUpdateManyMutationInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}

input CustomerContactUpdateManyWithWhereWithoutCustomerInput {
  data: CustomerContactUpdateManyMutationInput!
  where: CustomerContactScalarWhereInput!
}

input CustomerContactUpdateManyWithoutCustomerNestedInput {
  connect: [CustomerContactWhereUniqueInput!]
  connectOrCreate: [CustomerContactCreateOrConnectWithoutCustomerInput!]
  create: [CustomerContactCreateWithoutCustomerInput!]
  createMany: CustomerContactCreateManyCustomerInputEnvelope
  delete: [CustomerContactWhereUniqueInput!]
  deleteMany: [CustomerContactScalarWhereInput!]
  disconnect: [CustomerContactWhereUniqueInput!]
  set: [CustomerContactWhereUniqueInput!]
  update: [CustomerContactUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [CustomerContactUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [CustomerContactUpsertWithWhereUniqueWithoutCustomerInput!]
}

input CustomerContactUpdateWithWhereUniqueWithoutCustomerInput {
  data: CustomerContactUpdateWithoutCustomerInput!
  where: CustomerContactWhereUniqueInput!
}

input CustomerContactUpdateWithoutCustomerInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}

input CustomerContactUpsertWithWhereUniqueWithoutCustomerInput {
  create: CustomerContactCreateWithoutCustomerInput!
  update: CustomerContactUpdateWithoutCustomerInput!
  where: CustomerContactWhereUniqueInput!
}

input CustomerContactWhereInput {
  AND: [CustomerContactWhereInput!]
  NOT: [CustomerContactWhereInput!]
  OR: [CustomerContactWhereInput!]
  customer: CustomerRelationFilter
  customerId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  phone: StringFilter
}

input CustomerContactWhereUniqueInput {
  AND: [CustomerContactWhereInput!]
  NOT: [CustomerContactWhereInput!]
  OR: [CustomerContactWhereInput!]
  customer: CustomerRelationFilter
  customerId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: String
  lastName: StringFilter
  phone: StringFilter
}

type CustomerCount {
  CustomerContact(where: CustomerContactWhereInput): Int!
}

type CustomerCountAggregate {
  _all: Int!
  address: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
  phone: Int!
}

input CustomerCountOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
}

input CustomerCreateInput {
  CustomerContact: CustomerContactCreateNestedManyWithoutCustomerInput
  address: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
  phone: String!
}

input CustomerCreateManyInput {
  address: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
  phone: String!
}

input CustomerCreateNestedOneWithoutCustomerContactInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutCustomerContactInput
  create: CustomerCreateWithoutCustomerContactInput
}

input CustomerCreateOrConnectWithoutCustomerContactInput {
  create: CustomerCreateWithoutCustomerContactInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateWithoutCustomerContactInput {
  address: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
  phone: String!
}

type CustomerGroupBy {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  address: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  name: String!
  phone: String!
}

type CustomerMaxAggregate {
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
}

input CustomerMaxOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
}

type CustomerMinAggregate {
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
}

input CustomerMinOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
}

input CustomerOrderByWithAggregationInput {
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
}

input CustomerOrderByWithRelationInput {
  CustomerContact: CustomerContactOrderByRelationAggregateInput
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
}

input CustomerRelationFilter {
  is: CustomerWhereInput
  isNot: CustomerWhereInput
}

enum CustomerScalarFieldEnum {
  address
  dateCreated
  dateUpdated
  id
  name
  phone
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
}

input CustomerUpdateInput {
  CustomerContact: CustomerContactUpdateManyWithoutCustomerNestedInput
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
}

input CustomerUpdateManyMutationInput {
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
}

input CustomerUpdateOneRequiredWithoutCustomerContactNestedInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutCustomerContactInput
  create: CustomerCreateWithoutCustomerContactInput
  update: CustomerUpdateToOneWithWhereWithoutCustomerContactInput
  upsert: CustomerUpsertWithoutCustomerContactInput
}

input CustomerUpdateToOneWithWhereWithoutCustomerContactInput {
  data: CustomerUpdateWithoutCustomerContactInput!
  where: CustomerWhereInput
}

input CustomerUpdateWithoutCustomerContactInput {
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
}

input CustomerUpsertWithoutCustomerContactInput {
  create: CustomerCreateWithoutCustomerContactInput!
  update: CustomerUpdateWithoutCustomerContactInput!
  where: CustomerWhereInput
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  CustomerContact: CustomerContactListRelationFilter
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  address: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  name: StringFilter
  phone: StringFilter
}

input CustomerWhereUniqueInput {
  AND: [CustomerWhereInput!]
  CustomerContact: CustomerContactListRelationFilter
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  address: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: String
  name: StringFilter
  phone: StringFilter
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

type Mutation {
  createManyAndReturnCustomer(data: [CustomerCreateManyInput!]!): [CreateManyAndReturnCustomer!]!
  createManyAndReturnCustomerContact(data: [CustomerContactCreateManyInput!]!): [CreateManyAndReturnCustomerContact!]!
  createManyAndReturnUser(data: [UserCreateManyInput!]!): [CreateManyAndReturnUser!]!
  createManyCustomer(data: [CustomerCreateManyInput!]!): AffectedRowsOutput!
  createManyCustomerContact(data: [CustomerContactCreateManyInput!]!): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!): AffectedRowsOutput!
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneCustomerContact(data: CustomerContactCreateInput!): CustomerContact!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCustomer(where: CustomerWhereInput): AffectedRowsOutput!
  deleteManyCustomerContact(where: CustomerContactWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneCustomerContact(where: CustomerContactWhereUniqueInput!): CustomerContact
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): AffectedRowsOutput!
  updateManyCustomerContact(data: CustomerContactUpdateManyMutationInput!, where: CustomerContactWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateOneCustomerContact(data: CustomerContactUpdateInput!, where: CustomerContactWhereUniqueInput!): CustomerContact
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertOneCustomerContact(create: CustomerContactCreateInput!, update: CustomerContactUpdateInput!, where: CustomerContactWhereUniqueInput!): CustomerContact!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  aggregateCustomer(cursor: CustomerWhereUniqueInput, orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer!
  aggregateCustomerContact(cursor: CustomerContactWhereUniqueInput, orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): AggregateCustomerContact!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  customer(where: CustomerWhereUniqueInput!): Customer
  customerContact(where: CustomerContactWhereUniqueInput!): CustomerContact
  customerContacts(cursor: CustomerContactWhereUniqueInput, distinct: [CustomerContactScalarFieldEnum!], orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): [CustomerContact!]!
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstCustomerContact(cursor: CustomerContactWhereUniqueInput, distinct: [CustomerContactScalarFieldEnum!], orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): CustomerContact
  findFirstCustomerContactOrThrow(cursor: CustomerContactWhereUniqueInput, distinct: [CustomerContactScalarFieldEnum!], orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): CustomerContact
  findFirstCustomerOrThrow(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getCustomer(where: CustomerWhereUniqueInput!): Customer
  getCustomerContact(where: CustomerContactWhereUniqueInput!): CustomerContact
  getUser(where: UserWhereUniqueInput!): User
  groupByCustomer(by: [CustomerScalarFieldEnum!]!, having: CustomerScalarWhereWithAggregatesInput, orderBy: [CustomerOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerWhereInput): [CustomerGroupBy!]!
  groupByCustomerContact(by: [CustomerContactScalarFieldEnum!]!, having: CustomerContactScalarWhereWithAggregatesInput, orderBy: [CustomerContactOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): [CustomerContactGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  address: String!
  dateCreated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  phone: String!
  role: String!
}

type UserCountAggregate {
  _all: Int!
  address: Int!
  dateCreated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
  phone: Int!
  role: Int!
}

input UserCountOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
}

input UserCreateInput {
  address: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  role: String!
}

input UserCreateManyInput {
  address: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  role: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  address: String!
  dateCreated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  phone: String!
  role: String!
}

type UserMaxAggregate {
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
}

input UserMaxOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
}

type UserMinAggregate {
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
}

input UserMinOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
}

input UserOrderByWithRelationInput {
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
}

enum UserScalarFieldEnum {
  address
  dateCreated
  email
  firstName
  id
  lastName
  password
  phone
  role
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  role: StringWithAggregatesFilter
}

input UserUpdateInput {
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
}

input UserUpdateManyMutationInput {
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address: StringFilter
  dateCreated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
  role: StringFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address: StringFilter
  dateCreated: DateTimeFilter
  email: String
  firstName: StringFilter
  id: String
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
  role: StringFilter
}
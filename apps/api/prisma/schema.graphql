# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCustomer {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
}

type AggregateCustomerContact {
  _count: CustomerContactCountAggregate
  _max: CustomerContactMaxAggregate
  _min: CustomerContactMinAggregate
}

type AggregateState {
  _count: StateCountAggregate
  _max: StateMaxAggregate
  _min: StateMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type CreateManyAndReturnCustomer {
  city: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  name: String!
  phone: String!
  state: State!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

type CreateManyAndReturnCustomerContact {
  city: String!
  customer: Customer!
  customerId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
  state: State!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

type CreateManyAndReturnState {
  code: String!
  id: String!
  name: String!
}

type CreateManyAndReturnUser {
  city: String!
  dateCreated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  phone: String!
  role: String!
  state: State!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

type Customer {
  CustomerContact(cursor: CustomerContactWhereUniqueInput, distinct: [CustomerContactScalarFieldEnum!], orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): [CustomerContact!]!
  _count: CustomerCount
  city: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  name: String!
  phone: String!
  state: State!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

type CustomerContact {
  city: String!
  customer: Customer!
  customerId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
  state: State!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

type CustomerContactCountAggregate {
  _all: Int!
  city: Int!
  customerId: Int!
  dateCreated: Int!
  dateUpdated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  phone: Int!
  stateId: Int!
  streetAddress: Int!
  streetAddress2: Int!
  zip: Int!
}

input CustomerContactCountOrderByAggregateInput {
  city: SortOrder
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrder
  zip: SortOrder
}

input CustomerContactCreateInput {
  city: String!
  customer: CustomerCreateNestedOneWithoutCustomerContactInput!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  state: StateCreateNestedOneWithoutCustomerContactInput!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerContactCreateManyCustomerInput {
  city: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerContactCreateManyCustomerInputEnvelope {
  data: [CustomerContactCreateManyCustomerInput!]!
}

input CustomerContactCreateManyInput {
  city: String!
  customerId: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerContactCreateManyStateInput {
  city: String!
  customerId: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerContactCreateManyStateInputEnvelope {
  data: [CustomerContactCreateManyStateInput!]!
}

input CustomerContactCreateNestedManyWithoutCustomerInput {
  connect: [CustomerContactWhereUniqueInput!]
  connectOrCreate: [CustomerContactCreateOrConnectWithoutCustomerInput!]
  create: [CustomerContactCreateWithoutCustomerInput!]
  createMany: CustomerContactCreateManyCustomerInputEnvelope
}

input CustomerContactCreateNestedManyWithoutStateInput {
  connect: [CustomerContactWhereUniqueInput!]
  connectOrCreate: [CustomerContactCreateOrConnectWithoutStateInput!]
  create: [CustomerContactCreateWithoutStateInput!]
  createMany: CustomerContactCreateManyStateInputEnvelope
}

input CustomerContactCreateOrConnectWithoutCustomerInput {
  create: CustomerContactCreateWithoutCustomerInput!
  where: CustomerContactWhereUniqueInput!
}

input CustomerContactCreateOrConnectWithoutStateInput {
  create: CustomerContactCreateWithoutStateInput!
  where: CustomerContactWhereUniqueInput!
}

input CustomerContactCreateWithoutCustomerInput {
  city: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  state: StateCreateNestedOneWithoutCustomerContactInput!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerContactCreateWithoutStateInput {
  city: String!
  customer: CustomerCreateNestedOneWithoutCustomerContactInput!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

type CustomerContactGroupBy {
  _count: CustomerContactCountAggregate
  _max: CustomerContactMaxAggregate
  _min: CustomerContactMinAggregate
  city: String!
  customerId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerContactListRelationFilter {
  every: CustomerContactWhereInput
  none: CustomerContactWhereInput
  some: CustomerContactWhereInput
}

type CustomerContactMaxAggregate {
  city: String
  customerId: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  stateId: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerContactMaxOrderByAggregateInput {
  city: SortOrder
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrder
  zip: SortOrder
}

type CustomerContactMinAggregate {
  city: String
  customerId: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  stateId: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerContactMinOrderByAggregateInput {
  city: SortOrder
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrder
  zip: SortOrder
}

input CustomerContactOrderByRelationAggregateInput {
  _count: SortOrder
}

input CustomerContactOrderByWithAggregationInput {
  _count: CustomerContactCountOrderByAggregateInput
  _max: CustomerContactMaxOrderByAggregateInput
  _min: CustomerContactMinOrderByAggregateInput
  city: SortOrder
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrderInput
  zip: SortOrder
}

input CustomerContactOrderByWithRelationInput {
  city: SortOrder
  customer: CustomerOrderByWithRelationInput
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: StateOrderByWithRelationInput
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrderInput
  zip: SortOrder
}

enum CustomerContactScalarFieldEnum {
  city
  customerId
  dateCreated
  dateUpdated
  email
  firstName
  id
  lastName
  phone
  stateId
  streetAddress
  streetAddress2
  zip
}

input CustomerContactScalarWhereInput {
  AND: [CustomerContactScalarWhereInput!]
  NOT: [CustomerContactScalarWhereInput!]
  OR: [CustomerContactScalarWhereInput!]
  city: StringFilter
  customerId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  phone: StringFilter
  stateId: StringFilter
  streetAddress: StringFilter
  streetAddress2: StringNullableFilter
  zip: StringFilter
}

input CustomerContactScalarWhereWithAggregatesInput {
  AND: [CustomerContactScalarWhereWithAggregatesInput!]
  NOT: [CustomerContactScalarWhereWithAggregatesInput!]
  OR: [CustomerContactScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  customerId: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  stateId: StringWithAggregatesFilter
  streetAddress: StringWithAggregatesFilter
  streetAddress2: StringNullableWithAggregatesFilter
  zip: StringWithAggregatesFilter
}

input CustomerContactUpdateInput {
  city: String
  customer: CustomerUpdateOneRequiredWithoutCustomerContactNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: StateUpdateOneRequiredWithoutCustomerContactNestedInput
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerContactUpdateManyMutationInput {
  city: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerContactUpdateManyWithWhereWithoutCustomerInput {
  data: CustomerContactUpdateManyMutationInput!
  where: CustomerContactScalarWhereInput!
}

input CustomerContactUpdateManyWithWhereWithoutStateInput {
  data: CustomerContactUpdateManyMutationInput!
  where: CustomerContactScalarWhereInput!
}

input CustomerContactUpdateManyWithoutCustomerNestedInput {
  connect: [CustomerContactWhereUniqueInput!]
  connectOrCreate: [CustomerContactCreateOrConnectWithoutCustomerInput!]
  create: [CustomerContactCreateWithoutCustomerInput!]
  createMany: CustomerContactCreateManyCustomerInputEnvelope
  delete: [CustomerContactWhereUniqueInput!]
  deleteMany: [CustomerContactScalarWhereInput!]
  disconnect: [CustomerContactWhereUniqueInput!]
  set: [CustomerContactWhereUniqueInput!]
  update: [CustomerContactUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [CustomerContactUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [CustomerContactUpsertWithWhereUniqueWithoutCustomerInput!]
}

input CustomerContactUpdateManyWithoutStateNestedInput {
  connect: [CustomerContactWhereUniqueInput!]
  connectOrCreate: [CustomerContactCreateOrConnectWithoutStateInput!]
  create: [CustomerContactCreateWithoutStateInput!]
  createMany: CustomerContactCreateManyStateInputEnvelope
  delete: [CustomerContactWhereUniqueInput!]
  deleteMany: [CustomerContactScalarWhereInput!]
  disconnect: [CustomerContactWhereUniqueInput!]
  set: [CustomerContactWhereUniqueInput!]
  update: [CustomerContactUpdateWithWhereUniqueWithoutStateInput!]
  updateMany: [CustomerContactUpdateManyWithWhereWithoutStateInput!]
  upsert: [CustomerContactUpsertWithWhereUniqueWithoutStateInput!]
}

input CustomerContactUpdateWithWhereUniqueWithoutCustomerInput {
  data: CustomerContactUpdateWithoutCustomerInput!
  where: CustomerContactWhereUniqueInput!
}

input CustomerContactUpdateWithWhereUniqueWithoutStateInput {
  data: CustomerContactUpdateWithoutStateInput!
  where: CustomerContactWhereUniqueInput!
}

input CustomerContactUpdateWithoutCustomerInput {
  city: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: StateUpdateOneRequiredWithoutCustomerContactNestedInput
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerContactUpdateWithoutStateInput {
  city: String
  customer: CustomerUpdateOneRequiredWithoutCustomerContactNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerContactUpsertWithWhereUniqueWithoutCustomerInput {
  create: CustomerContactCreateWithoutCustomerInput!
  update: CustomerContactUpdateWithoutCustomerInput!
  where: CustomerContactWhereUniqueInput!
}

input CustomerContactUpsertWithWhereUniqueWithoutStateInput {
  create: CustomerContactCreateWithoutStateInput!
  update: CustomerContactUpdateWithoutStateInput!
  where: CustomerContactWhereUniqueInput!
}

input CustomerContactWhereInput {
  AND: [CustomerContactWhereInput!]
  NOT: [CustomerContactWhereInput!]
  OR: [CustomerContactWhereInput!]
  city: StringFilter
  customer: CustomerRelationFilter
  customerId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  phone: StringFilter
  state: StateRelationFilter
  stateId: StringFilter
  streetAddress: StringFilter
  streetAddress2: StringNullableFilter
  zip: StringFilter
}

input CustomerContactWhereUniqueInput {
  AND: [CustomerContactWhereInput!]
  NOT: [CustomerContactWhereInput!]
  OR: [CustomerContactWhereInput!]
  city: StringFilter
  customer: CustomerRelationFilter
  customerId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: String
  lastName: StringFilter
  phone: StringFilter
  state: StateRelationFilter
  stateId: StringFilter
  streetAddress: StringFilter
  streetAddress2: StringNullableFilter
  zip: StringFilter
}

type CustomerCount {
  CustomerContact(where: CustomerContactWhereInput): Int!
}

type CustomerCountAggregate {
  _all: Int!
  city: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
  phone: Int!
  stateId: Int!
  streetAddress: Int!
  streetAddress2: Int!
  zip: Int!
}

input CustomerCountOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrder
  zip: SortOrder
}

input CustomerCreateInput {
  CustomerContact: CustomerContactCreateNestedManyWithoutCustomerInput
  city: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
  phone: String!
  state: StateCreateNestedOneWithoutCustomerInput!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerCreateManyInput {
  city: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
  phone: String!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerCreateManyStateInput {
  city: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
  phone: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerCreateManyStateInputEnvelope {
  data: [CustomerCreateManyStateInput!]!
}

input CustomerCreateNestedManyWithoutStateInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutStateInput!]
  create: [CustomerCreateWithoutStateInput!]
  createMany: CustomerCreateManyStateInputEnvelope
}

input CustomerCreateNestedOneWithoutCustomerContactInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutCustomerContactInput
  create: CustomerCreateWithoutCustomerContactInput
}

input CustomerCreateOrConnectWithoutCustomerContactInput {
  create: CustomerCreateWithoutCustomerContactInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutStateInput {
  create: CustomerCreateWithoutStateInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateWithoutCustomerContactInput {
  city: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
  phone: String!
  state: StateCreateNestedOneWithoutCustomerInput!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerCreateWithoutStateInput {
  CustomerContact: CustomerContactCreateNestedManyWithoutCustomerInput
  city: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
  phone: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

type CustomerGroupBy {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  city: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  name: String!
  phone: String!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input CustomerListRelationFilter {
  every: CustomerWhereInput
  none: CustomerWhereInput
  some: CustomerWhereInput
}

type CustomerMaxAggregate {
  city: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
  stateId: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerMaxOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrder
  zip: SortOrder
}

type CustomerMinAggregate {
  city: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
  stateId: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerMinOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrder
  zip: SortOrder
}

input CustomerOrderByRelationAggregateInput {
  _count: SortOrder
}

input CustomerOrderByWithAggregationInput {
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrderInput
  zip: SortOrder
}

input CustomerOrderByWithRelationInput {
  CustomerContact: CustomerContactOrderByRelationAggregateInput
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  state: StateOrderByWithRelationInput
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrderInput
  zip: SortOrder
}

input CustomerRelationFilter {
  is: CustomerWhereInput
  isNot: CustomerWhereInput
}

enum CustomerScalarFieldEnum {
  city
  dateCreated
  dateUpdated
  id
  name
  phone
  stateId
  streetAddress
  streetAddress2
  zip
}

input CustomerScalarWhereInput {
  AND: [CustomerScalarWhereInput!]
  NOT: [CustomerScalarWhereInput!]
  OR: [CustomerScalarWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  name: StringFilter
  phone: StringFilter
  stateId: StringFilter
  streetAddress: StringFilter
  streetAddress2: StringNullableFilter
  zip: StringFilter
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  stateId: StringWithAggregatesFilter
  streetAddress: StringWithAggregatesFilter
  streetAddress2: StringNullableWithAggregatesFilter
  zip: StringWithAggregatesFilter
}

input CustomerUpdateInput {
  CustomerContact: CustomerContactUpdateManyWithoutCustomerNestedInput
  city: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
  state: StateUpdateOneRequiredWithoutCustomerNestedInput
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerUpdateManyMutationInput {
  city: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerUpdateManyWithWhereWithoutStateInput {
  data: CustomerUpdateManyMutationInput!
  where: CustomerScalarWhereInput!
}

input CustomerUpdateManyWithoutStateNestedInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutStateInput!]
  create: [CustomerCreateWithoutStateInput!]
  createMany: CustomerCreateManyStateInputEnvelope
  delete: [CustomerWhereUniqueInput!]
  deleteMany: [CustomerScalarWhereInput!]
  disconnect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutStateInput!]
  updateMany: [CustomerUpdateManyWithWhereWithoutStateInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutStateInput!]
}

input CustomerUpdateOneRequiredWithoutCustomerContactNestedInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutCustomerContactInput
  create: CustomerCreateWithoutCustomerContactInput
  update: CustomerUpdateToOneWithWhereWithoutCustomerContactInput
  upsert: CustomerUpsertWithoutCustomerContactInput
}

input CustomerUpdateToOneWithWhereWithoutCustomerContactInput {
  data: CustomerUpdateWithoutCustomerContactInput!
  where: CustomerWhereInput
}

input CustomerUpdateWithWhereUniqueWithoutStateInput {
  data: CustomerUpdateWithoutStateInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpdateWithoutCustomerContactInput {
  city: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
  state: StateUpdateOneRequiredWithoutCustomerNestedInput
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerUpdateWithoutStateInput {
  CustomerContact: CustomerContactUpdateManyWithoutCustomerNestedInput
  city: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
  phone: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input CustomerUpsertWithWhereUniqueWithoutStateInput {
  create: CustomerCreateWithoutStateInput!
  update: CustomerUpdateWithoutStateInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpsertWithoutCustomerContactInput {
  create: CustomerCreateWithoutCustomerContactInput!
  update: CustomerUpdateWithoutCustomerContactInput!
  where: CustomerWhereInput
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  CustomerContact: CustomerContactListRelationFilter
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  name: StringFilter
  phone: StringFilter
  state: StateRelationFilter
  stateId: StringFilter
  streetAddress: StringFilter
  streetAddress2: StringNullableFilter
  zip: StringFilter
}

input CustomerWhereUniqueInput {
  AND: [CustomerWhereInput!]
  CustomerContact: CustomerContactListRelationFilter
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: String
  name: StringFilter
  phone: StringFilter
  state: StateRelationFilter
  stateId: StringFilter
  streetAddress: StringFilter
  streetAddress2: StringNullableFilter
  zip: StringFilter
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

type Mutation {
  createManyAndReturnCustomer(data: [CustomerCreateManyInput!]!): [CreateManyAndReturnCustomer!]!
  createManyAndReturnCustomerContact(data: [CustomerContactCreateManyInput!]!): [CreateManyAndReturnCustomerContact!]!
  createManyAndReturnState(data: [StateCreateManyInput!]!): [CreateManyAndReturnState!]!
  createManyAndReturnUser(data: [UserCreateManyInput!]!): [CreateManyAndReturnUser!]!
  createManyCustomer(data: [CustomerCreateManyInput!]!): AffectedRowsOutput!
  createManyCustomerContact(data: [CustomerContactCreateManyInput!]!): AffectedRowsOutput!
  createManyState(data: [StateCreateManyInput!]!): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!): AffectedRowsOutput!
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneCustomerContact(data: CustomerContactCreateInput!): CustomerContact!
  createOneState(data: StateCreateInput!): State!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCustomer(where: CustomerWhereInput): AffectedRowsOutput!
  deleteManyCustomerContact(where: CustomerContactWhereInput): AffectedRowsOutput!
  deleteManyState(where: StateWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneCustomerContact(where: CustomerContactWhereUniqueInput!): CustomerContact
  deleteOneState(where: StateWhereUniqueInput!): State
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): AffectedRowsOutput!
  updateManyCustomerContact(data: CustomerContactUpdateManyMutationInput!, where: CustomerContactWhereInput): AffectedRowsOutput!
  updateManyState(data: StateUpdateManyMutationInput!, where: StateWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateOneCustomerContact(data: CustomerContactUpdateInput!, where: CustomerContactWhereUniqueInput!): CustomerContact
  updateOneState(data: StateUpdateInput!, where: StateWhereUniqueInput!): State
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertOneCustomerContact(create: CustomerContactCreateInput!, update: CustomerContactUpdateInput!, where: CustomerContactWhereUniqueInput!): CustomerContact!
  upsertOneState(create: StateCreateInput!, update: StateUpdateInput!, where: StateWhereUniqueInput!): State!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type Query {
  aggregateCustomer(cursor: CustomerWhereUniqueInput, orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer!
  aggregateCustomerContact(cursor: CustomerContactWhereUniqueInput, orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): AggregateCustomerContact!
  aggregateState(cursor: StateWhereUniqueInput, orderBy: [StateOrderByWithRelationInput!], skip: Int, take: Int, where: StateWhereInput): AggregateState!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  customer(where: CustomerWhereUniqueInput!): Customer
  customerContact(where: CustomerContactWhereUniqueInput!): CustomerContact
  customerContacts(cursor: CustomerContactWhereUniqueInput, distinct: [CustomerContactScalarFieldEnum!], orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): [CustomerContact!]!
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstCustomerContact(cursor: CustomerContactWhereUniqueInput, distinct: [CustomerContactScalarFieldEnum!], orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): CustomerContact
  findFirstCustomerContactOrThrow(cursor: CustomerContactWhereUniqueInput, distinct: [CustomerContactScalarFieldEnum!], orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): CustomerContact
  findFirstCustomerOrThrow(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstState(cursor: StateWhereUniqueInput, distinct: [StateScalarFieldEnum!], orderBy: [StateOrderByWithRelationInput!], skip: Int, take: Int, where: StateWhereInput): State
  findFirstStateOrThrow(cursor: StateWhereUniqueInput, distinct: [StateScalarFieldEnum!], orderBy: [StateOrderByWithRelationInput!], skip: Int, take: Int, where: StateWhereInput): State
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getCustomer(where: CustomerWhereUniqueInput!): Customer
  getCustomerContact(where: CustomerContactWhereUniqueInput!): CustomerContact
  getState(where: StateWhereUniqueInput!): State
  getUser(where: UserWhereUniqueInput!): User
  groupByCustomer(by: [CustomerScalarFieldEnum!]!, having: CustomerScalarWhereWithAggregatesInput, orderBy: [CustomerOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerWhereInput): [CustomerGroupBy!]!
  groupByCustomerContact(by: [CustomerContactScalarFieldEnum!]!, having: CustomerContactScalarWhereWithAggregatesInput, orderBy: [CustomerContactOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): [CustomerContactGroupBy!]!
  groupByState(by: [StateScalarFieldEnum!]!, having: StateScalarWhereWithAggregatesInput, orderBy: [StateOrderByWithAggregationInput!], skip: Int, take: Int, where: StateWhereInput): [StateGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  search(query: String!): [SearchResult!]
  signin(password: String!, username: String!): String
  state(where: StateWhereUniqueInput!): State
  states(cursor: StateWhereUniqueInput, distinct: [StateScalarFieldEnum!], orderBy: [StateOrderByWithRelationInput!], skip: Int, take: Int, where: StateWhereInput): [State!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type SearchResult {
  description: String
  id: String
  name: String
  type: Float
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

type State {
  _count: StateCount
  code: String!
  customer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  customerContact(cursor: CustomerContactWhereUniqueInput, distinct: [CustomerContactScalarFieldEnum!], orderBy: [CustomerContactOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerContactWhereInput): [CustomerContact!]!
  id: String!
  name: String!
  user(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type StateCount {
  customer(where: CustomerWhereInput): Int!
  customerContact(where: CustomerContactWhereInput): Int!
  user(where: UserWhereInput): Int!
}

type StateCountAggregate {
  _all: Int!
  code: Int!
  id: Int!
  name: Int!
}

input StateCountOrderByAggregateInput {
  code: SortOrder
  id: SortOrder
  name: SortOrder
}

input StateCreateInput {
  code: String!
  customer: CustomerCreateNestedManyWithoutStateInput
  customerContact: CustomerContactCreateNestedManyWithoutStateInput
  id: String
  name: String!
  user: UserCreateNestedManyWithoutStateInput
}

input StateCreateManyInput {
  code: String!
  id: String
  name: String!
}

input StateCreateNestedOneWithoutCustomerContactInput {
  connect: StateWhereUniqueInput
  connectOrCreate: StateCreateOrConnectWithoutCustomerContactInput
  create: StateCreateWithoutCustomerContactInput
}

input StateCreateNestedOneWithoutCustomerInput {
  connect: StateWhereUniqueInput
  connectOrCreate: StateCreateOrConnectWithoutCustomerInput
  create: StateCreateWithoutCustomerInput
}

input StateCreateNestedOneWithoutUserInput {
  connect: StateWhereUniqueInput
  connectOrCreate: StateCreateOrConnectWithoutUserInput
  create: StateCreateWithoutUserInput
}

input StateCreateOrConnectWithoutCustomerContactInput {
  create: StateCreateWithoutCustomerContactInput!
  where: StateWhereUniqueInput!
}

input StateCreateOrConnectWithoutCustomerInput {
  create: StateCreateWithoutCustomerInput!
  where: StateWhereUniqueInput!
}

input StateCreateOrConnectWithoutUserInput {
  create: StateCreateWithoutUserInput!
  where: StateWhereUniqueInput!
}

input StateCreateWithoutCustomerContactInput {
  code: String!
  customer: CustomerCreateNestedManyWithoutStateInput
  id: String
  name: String!
  user: UserCreateNestedManyWithoutStateInput
}

input StateCreateWithoutCustomerInput {
  code: String!
  customerContact: CustomerContactCreateNestedManyWithoutStateInput
  id: String
  name: String!
  user: UserCreateNestedManyWithoutStateInput
}

input StateCreateWithoutUserInput {
  code: String!
  customer: CustomerCreateNestedManyWithoutStateInput
  customerContact: CustomerContactCreateNestedManyWithoutStateInput
  id: String
  name: String!
}

type StateGroupBy {
  _count: StateCountAggregate
  _max: StateMaxAggregate
  _min: StateMinAggregate
  code: String!
  id: String!
  name: String!
}

type StateMaxAggregate {
  code: String
  id: String
  name: String
}

input StateMaxOrderByAggregateInput {
  code: SortOrder
  id: SortOrder
  name: SortOrder
}

type StateMinAggregate {
  code: String
  id: String
  name: String
}

input StateMinOrderByAggregateInput {
  code: SortOrder
  id: SortOrder
  name: SortOrder
}

input StateOrderByWithAggregationInput {
  _count: StateCountOrderByAggregateInput
  _max: StateMaxOrderByAggregateInput
  _min: StateMinOrderByAggregateInput
  code: SortOrder
  id: SortOrder
  name: SortOrder
}

input StateOrderByWithRelationInput {
  code: SortOrder
  customer: CustomerOrderByRelationAggregateInput
  customerContact: CustomerContactOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
  user: UserOrderByRelationAggregateInput
}

input StateRelationFilter {
  is: StateWhereInput
  isNot: StateWhereInput
}

enum StateScalarFieldEnum {
  code
  id
  name
}

input StateScalarWhereWithAggregatesInput {
  AND: [StateScalarWhereWithAggregatesInput!]
  NOT: [StateScalarWhereWithAggregatesInput!]
  OR: [StateScalarWhereWithAggregatesInput!]
  code: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input StateUpdateInput {
  code: String
  customer: CustomerUpdateManyWithoutStateNestedInput
  customerContact: CustomerContactUpdateManyWithoutStateNestedInput
  id: String
  name: String
  user: UserUpdateManyWithoutStateNestedInput
}

input StateUpdateManyMutationInput {
  code: String
  id: String
  name: String
}

input StateUpdateOneRequiredWithoutCustomerContactNestedInput {
  connect: StateWhereUniqueInput
  connectOrCreate: StateCreateOrConnectWithoutCustomerContactInput
  create: StateCreateWithoutCustomerContactInput
  update: StateUpdateToOneWithWhereWithoutCustomerContactInput
  upsert: StateUpsertWithoutCustomerContactInput
}

input StateUpdateOneRequiredWithoutCustomerNestedInput {
  connect: StateWhereUniqueInput
  connectOrCreate: StateCreateOrConnectWithoutCustomerInput
  create: StateCreateWithoutCustomerInput
  update: StateUpdateToOneWithWhereWithoutCustomerInput
  upsert: StateUpsertWithoutCustomerInput
}

input StateUpdateOneRequiredWithoutUserNestedInput {
  connect: StateWhereUniqueInput
  connectOrCreate: StateCreateOrConnectWithoutUserInput
  create: StateCreateWithoutUserInput
  update: StateUpdateToOneWithWhereWithoutUserInput
  upsert: StateUpsertWithoutUserInput
}

input StateUpdateToOneWithWhereWithoutCustomerContactInput {
  data: StateUpdateWithoutCustomerContactInput!
  where: StateWhereInput
}

input StateUpdateToOneWithWhereWithoutCustomerInput {
  data: StateUpdateWithoutCustomerInput!
  where: StateWhereInput
}

input StateUpdateToOneWithWhereWithoutUserInput {
  data: StateUpdateWithoutUserInput!
  where: StateWhereInput
}

input StateUpdateWithoutCustomerContactInput {
  code: String
  customer: CustomerUpdateManyWithoutStateNestedInput
  id: String
  name: String
  user: UserUpdateManyWithoutStateNestedInput
}

input StateUpdateWithoutCustomerInput {
  code: String
  customerContact: CustomerContactUpdateManyWithoutStateNestedInput
  id: String
  name: String
  user: UserUpdateManyWithoutStateNestedInput
}

input StateUpdateWithoutUserInput {
  code: String
  customer: CustomerUpdateManyWithoutStateNestedInput
  customerContact: CustomerContactUpdateManyWithoutStateNestedInput
  id: String
  name: String
}

input StateUpsertWithoutCustomerContactInput {
  create: StateCreateWithoutCustomerContactInput!
  update: StateUpdateWithoutCustomerContactInput!
  where: StateWhereInput
}

input StateUpsertWithoutCustomerInput {
  create: StateCreateWithoutCustomerInput!
  update: StateUpdateWithoutCustomerInput!
  where: StateWhereInput
}

input StateUpsertWithoutUserInput {
  create: StateCreateWithoutUserInput!
  update: StateUpdateWithoutUserInput!
  where: StateWhereInput
}

input StateWhereInput {
  AND: [StateWhereInput!]
  NOT: [StateWhereInput!]
  OR: [StateWhereInput!]
  code: StringFilter
  customer: CustomerListRelationFilter
  customerContact: CustomerContactListRelationFilter
  id: StringFilter
  name: StringFilter
  user: UserListRelationFilter
}

input StateWhereUniqueInput {
  AND: [StateWhereInput!]
  NOT: [StateWhereInput!]
  OR: [StateWhereInput!]
  code: StringFilter
  customer: CustomerListRelationFilter
  customerContact: CustomerContactListRelationFilter
  id: String
  name: StringFilter
  user: UserListRelationFilter
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  city: String!
  dateCreated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  phone: String!
  role: String!
  state: State!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

type UserCountAggregate {
  _all: Int!
  city: Int!
  dateCreated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
  phone: Int!
  role: Int!
  stateId: Int!
  streetAddress: Int!
  streetAddress2: Int!
  zip: Int!
}

input UserCountOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrder
  zip: SortOrder
}

input UserCreateInput {
  city: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  role: String!
  state: StateCreateNestedOneWithoutUserInput!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input UserCreateManyInput {
  city: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  role: String!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input UserCreateManyStateInput {
  city: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  role: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input UserCreateManyStateInputEnvelope {
  data: [UserCreateManyStateInput!]!
}

input UserCreateNestedManyWithoutStateInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutStateInput!]
  create: [UserCreateWithoutStateInput!]
  createMany: UserCreateManyStateInputEnvelope
}

input UserCreateOrConnectWithoutStateInput {
  create: UserCreateWithoutStateInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutStateInput {
  city: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  role: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  city: String!
  dateCreated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  phone: String!
  role: String!
  stateId: String!
  streetAddress: String!
  streetAddress2: String
  zip: String!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  city: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
  stateId: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input UserMaxOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrder
  zip: SortOrder
}

type UserMinAggregate {
  city: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
  stateId: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input UserMinOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrder
  zip: SortOrder
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  city: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrderInput
  zip: SortOrder
}

input UserOrderByWithRelationInput {
  city: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
  state: StateOrderByWithRelationInput
  stateId: SortOrder
  streetAddress: SortOrder
  streetAddress2: SortOrderInput
  zip: SortOrder
}

enum UserScalarFieldEnum {
  city
  dateCreated
  email
  firstName
  id
  lastName
  password
  phone
  role
  stateId
  streetAddress
  streetAddress2
  zip
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
  role: StringFilter
  stateId: StringFilter
  streetAddress: StringFilter
  streetAddress2: StringNullableFilter
  zip: StringFilter
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  role: StringWithAggregatesFilter
  stateId: StringWithAggregatesFilter
  streetAddress: StringWithAggregatesFilter
  streetAddress2: StringNullableWithAggregatesFilter
  zip: StringWithAggregatesFilter
}

input UserUpdateInput {
  city: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
  state: StateUpdateOneRequiredWithoutUserNestedInput
  streetAddress: String
  streetAddress2: String
  zip: String
}

input UserUpdateManyMutationInput {
  city: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input UserUpdateManyWithWhereWithoutStateInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutStateNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutStateInput!]
  create: [UserCreateWithoutStateInput!]
  createMany: UserCreateManyStateInputEnvelope
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutStateInput!]
  updateMany: [UserUpdateManyWithWhereWithoutStateInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutStateInput!]
}

input UserUpdateWithWhereUniqueWithoutStateInput {
  data: UserUpdateWithoutStateInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutStateInput {
  city: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
  streetAddress: String
  streetAddress2: String
  zip: String
}

input UserUpsertWithWhereUniqueWithoutStateInput {
  create: UserCreateWithoutStateInput!
  update: UserUpdateWithoutStateInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
  role: StringFilter
  state: StateRelationFilter
  stateId: StringFilter
  streetAddress: StringFilter
  streetAddress2: StringNullableFilter
  zip: StringFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  email: String
  firstName: StringFilter
  id: String
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
  role: StringFilter
  state: StateRelationFilter
  stateId: StringFilter
  streetAddress: StringFilter
  streetAddress2: StringNullableFilter
  zip: StringFilter
}